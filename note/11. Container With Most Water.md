# 11. Container With Most Water
### [题目链接]((https://leetcode.com/problems/container-with-most-water/description/))
### 题目大意
  给定n个非负整数a1，a2，...，an，其中每个代表坐标（i，ai）处的一个点。绘制n条垂直线，使得线i的两个端点处于（i，ai）和（i，0）处。找到两条线，它们与x轴一起形成一个容器，以使容器包含最多的水。需要考虑水溢出的情况，所以容器的大小是由较短的垂直线和两条线之间的距离决定的。
  
### 方法一：暴力破解
  
  首先想到的方法当然是暴力破解了，那么会有 
   <img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large \mathrm{C}_n^k" style="border:none;">
  种情况，显然时间复杂度为n平方，一般情况下会超时的，这里贴下代码：
   
   	class Solution {
	public:
	    int maxArea(vector<int>& height) {
	        int maxArea;
	        for(int i = 0; i < height.size()-1; i++) {
	            for(int j = i + 1; j < height.size(); j++) {
	                maxArea = max(maxArea, min(height[i], height[j])*(j-i));
	            }
	        }
	        return maxArea;
	    }
	};
	
### 方法二：两边逼近
  
  1. 选择最左边的值和最右边的值，可以计算出面积，即容器的大小
  2. 这时我们有两种选择。如果左边的线长度小于右边的线长度，那么我们选择选左边的下一条线；如果左边的线段长度大于右边的线段长度，则选择右边的下一条线（必需改变相对较小长度的线，那是因为如果改变长度较大的线段端，那么他们的面积始终不会增加）。
  3. 知道左边的x轴坐标大于右边线段的x轴坐标停止

下面是AC代码：
	
	
	class Solution {
	public:
	    int maxArea(vector<int>& height) {
	        int maxArea = 0;
	        for(int i = 0, j = height.size()-1; i < j;) {
	            maxArea = max(maxArea, min(height[i], height[j])*(j-i));
	            if(height[i] < height[j])
	                i++;
	            else
	                j--;
	        }
	        return maxArea;
	    }
	};	

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   